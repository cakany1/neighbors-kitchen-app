import fs from "node:fs";
import path from "node:path";

const token = process.env.GITHUB_TOKEN;
const repoFull = process.env.REPO; // "owner/repo"
const sha = process.env.SHA;

if (!token || !repoFull) {
  console.error("Missing GITHUB_TOKEN or REPO env.");
  process.exit(1);
}

const [owner, repo] = repoFull.split("/");

async function gh(url) {
  const res = await fetch(`https://api.github.com${url}`, {
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: "application/vnd.github+json",
      "X-GitHub-Api-Version": "2022-11-28",
      "User-Agent": "docs-sync-bot",
    },
  });
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`GitHub API error ${res.status}: ${text}`);
  }
  return res.json();
}

function hasLabel(issue, name) {
  return (issue.labels || []).some((l) => (typeof l === "string" ? l === name : l.name === name));
}

function issueLine(issue) {
  return `- #${issue.number} – ${issue.title}`;
}

async function listIssues(state) {
  // Pull issues (not PRs)
  // Using issues endpoint with state=open/closed and filtering out pull_request
  const per_page = 100;
  let page = 1;
  let out = [];
  while (true) {
    const items = await gh(`/repos/${owner}/${repo}/issues?state=${state}&per_page=${per_page}&page=${page}`);
    const issuesOnly = items.filter((it) => !it.pull_request);
    out.push(...issuesOnly);
    if (items.length < per_page) break;
    page++;
    if (page > 10) break; // safety
  }
  return out;
}

function buildSprintStatus({ openIssues, closedIssues }) {
  const inProgress = openIssues.filter((i) => hasLabel(i, "ai-in-progress"));
  const inReview = openIssues.filter((i) => hasLabel(i, "ai-review"));

  const running = openIssues
    .filter((i) => hasLabel(i, "P0") || hasLabel(i, "P1") || hasLabel(i, "P2"))
    .sort((a, b) => a.number - b.number);

  // last completed: closed in last 14 days (heuristic, deterministic)
  const cutoff = Date.now() - 14 * 24 * 60 * 60 * 1000;
  const recentlyClosed = closedIssues
    .filter((i) => new Date(i.closed_at || 0).getTime() >= cutoff)
    .sort((a, b) => new Date(b.closed_at).getTime() - new Date(a.closed_at).getTime())
    .slice(0, 10);

  const jsonRule = `- touches:i18n-json ist serialisiert (nie parallel).`;

  // Risks cannot be derived safely -> keep placeholder
  return `# SPRINT_STATUS

## Laufende Issues (Nummer + Kurzbeschreibung)
${running.length ? running.map(issueLine).join("\n") : "- (keine offenen Issues gefunden)"}

## In Progress
${inProgress.length ? inProgress.map(issueLine).join("\n") : "- (leer)"}

## In Review
${inReview.length ? inReview.map(issueLine).join("\n") : "- (leer)"}

## Letzte abgeschlossene Issues
${recentlyClosed.length ? recentlyClosed.map(issueLine).join("\n") : "- (keine kürzlich geschlossenen Issues gefunden)"}

## Aktuelle Risiken
- (manuell pflegen) Release-Risiken, offene Compliance/Store-Items, i18n-Kollisionen, DB-Migrationen

## Parallelisierungsregeln (Frontend/Backend)
- Backend (touches:db / touches:stripe) nur parallel zu Frontend, wenn keine Collision Tags überlappen.
${jsonRule}
- touches:auth nicht parallel zu anderen touches:auth Tasks.

## JSON-Serialisierungsstatus
${jsonRule}

## Build-Disziplin Status
- Build-Gate aktiv: bun run build
- Lint-Gate aktiv: bun run lint
- PR-Review Gate aktiv: Required checks must be green before merge

(Generated by docs-sync bot from GitHub Issues @ ${sha})
`;
}

function updateActivePriorityIssues(existingText) {
  // Minimal, deterministic update:
  // - Add/refresh a header note with "Last sync"
  // - Keep the rest untouched (so you remain in control)
  const stamp = `Last sync: ${new Date().toISOString()}`;
  if (existingText.includes("Last sync:")) {
    return existingText.replace(/Last sync:.*$/m, stamp);
  }
  // Insert after first header block if possible
  const lines = existingText.split("\n");
  const insertAt = Math.min(8, lines.length);
  lines.splice(insertAt, 0, "", stamp, "");
  return lines.join("\n");
}

(async () => {
  const openIssues = await listIssues("open");
  const closedIssues = await listIssues("closed");

  // 1) .SPRINT_STATUS.md overwrite (authoritative snapshot)
  const sprint = buildSprintStatus({ openIssues, closedIssues });
  fs.writeFileSync(path.resolve(".SPRINT_STATUS.md"), sprint, "utf8");

  // 2) .ACTIVE_PRIORITY_ISSUES.md minimal-touch stamp (keeps manual content)
  const activePath = path.resolve(".ACTIVE_PRIORITY_ISSUES.md");
  if (fs.existsSync(activePath)) {
    const active = fs.readFileSync(activePath, "utf8");
    fs.writeFileSync(activePath, updateActivePriorityIssues(active), "utf8");
  } else {
    fs.writeFileSync(
      activePath,
      `# Neighbors Kitchen – ACTIVE PRIORITY ISSUES (App Store Release Phase 1)\n\nLast sync: ${new Date().toISOString()}\n\n(Manuell pflegen)\n`,
      "utf8"
    );
  }

  // 3) .PROJECT_CONTEXT.md intentionally untouched (stable by policy)
})();
